#!/usr/bin/env python

import argparse
import sys
import os.path
import hashlib
from Crypto.Cipher import AES
import operator
import json
import re

HARDCODED_STRING = "e6f5bfbaae81a4496b5489f"
GALLERY_LOCATION = -1
OUT_OF_GALLERY_LOCATION = -2

def handle_read(options):
    log_path = options.log

    if log_path == None:
        # we need the last argument to be the path to log
        return -1

    if options.token == None or re.match('^[\w]+$', options.token) is None:
        # need to submit a token and be alpha numeric
        return -1

    if not os.path.isfile(log_path):
        # can't read non existant log
        return -1

    f=open(log_path, 'r')
    raw = f.read()
    f.close()
    nonce = raw[:AES.block_size]
    ciphertext = raw[AES.block_size:]

    # decrypted under the -K option passed in as a 256 hash
    key = hashlib.sha256(options.token).digest()
    obj = AES.new(key, AES.MODE_CFB, nonce)

    message = obj.decrypt(ciphertext)
    hardcode_attempt = message[:len(HARDCODED_STRING)]

    if hardcode_attempt != HARDCODED_STRING:
        # token was not correct if it didn't decrypt
        # to the hardcoded string properly
        return -2

    # hsh is sha256 which is 32 string characters
    hsh = message[len(HARDCODED_STRING):len(HARDCODED_STRING) + 32]
    log_data = message[len(HARDCODED_STRING) + 32:]

    if hsh != hashlib.sha256(log_data).digest():
        # hsh was not correct, probably somebody
        # mucked the data
        return -2

    # rest of data is json

    data = json.loads(log_data)

    if options.current_state:
        guests = []
        employees = []
        room_info = {}
        for guest in data['g']:
            info = data['g'][guest]
            room = info['s']
            if room == OUT_OF_GALLERY_LOCATION:
                # ppl outside shouldn't show up
                continue
            guests.append(guest)
            if room == GALLERY_LOCATION:
                # don't include ppl in gallery in room analysis
                continue
            if room in room_info:
                room_info[room].append(guest)
            else:
                room_info[room] = [guest]
        for employee in data['e']:
            info = data['e'][employee]
            room = info['s']
            if room == OUT_OF_GALLERY_LOCATION:
                # ppl outside shouldn't show up
                continue
            employees.append(employee)
            if room == GALLERY_LOCATION:
                # don't include ppl in gallery in room analysis
                continue
            if room in room_info:
                room_info[room].append(employee)
            else:
                room_info[room] = [employee]

        guests.sort()
        employees.sort()

        keys = room_info.keys()
        keys.sort()

        if options.html:
            html = "<html><body><table><tr><th>Employee</th><th>Guest</th></tr><tr>"
            html += "<td>" + ",".join(employees) + "</td><td>" + ",".join(guests) + "</td>"
            html += "</tr></table>"

            html += "<table><tr><th>Room ID</th><th>Occupants</th></tr>"

            for room in keys:
                values = room_info[room]
                values.sort()
                html += "<tr><td>" + str(room) + "</td><td>" + ",".join(values) + "</td></tr>"

            html += "</table></body></html>"
            sys.stdout.write(html)

        else:

            result = [",".join(employees), ",".join(guests)]

            for room in keys:
                values = room_info[room]
                values.sort()
                result.append(str(room) + ': ' + ",".join(values))

            sys.stdout.write("\n".join(result))

        # success printed current state
        return 0

    if options.rooms_entered:
        if options.guest_names:
            assert(options.employee_names == None)
            assert(len(options.guest_names) == 1)
            datalog = data['g'][options.guest_names[0]]
        else:
            assert(len(options.employee_names) == 1)
            datalog = data['e'][options.employee_names[0]]

        if options.html:
            html = "<html><body><table><tr><th>Rooms</th></tr>"

            for room in datalog['r']:
                html += "<tr><td>" + str(room) + "</td></tr>"

            html += "</table></body></html>"

            sys.stdout.write(html)
        else:
            sys.stdout.write(",".join(datalog['r']))

        # successfully printed rooms_entered
        return 0

    if options.total_time:
        assert(options.html == False)
        if options.guest_names:
            assert(options.employee_names == None)
            assert(len(options.guest_names) == 1)

            if options.guest_names[0] not in data['g']:
                datalog = data['g'][options.guest_names[0]]
            else:
                return 0 # print nothing
        else:
            assert(len(options.employee_names) == 1)
            if options.employee_names[0] not in data['e'][options.employee_names[0]]:
                datalog = data['e'][options.employee_names[0]]
            else:
                return 0 # print nothing

        arr = datalog['ga'] # look at ranges in the gallery
        time = 0

        for i in range(len(arr) / 2):
            lower = arr[i * 2]
            upper = arr[(i * 2) + 1]
            time += (upper - lower)

        if len(arr) % 2 == 1:
            lower = arr[-1]
            upper = data['t'] # current time
            time += (upper - lower)

        sys.stdout.write(str(time))

        # successful print total time in gallery
        return 0

    if options.matching_rooms:
        other_targets = []
        # other_targets will be array of datalogs that the target needs
        # to be in the same room as
        if options.employee_names:
            # use first employee as target
            target = data['e'][options.employee_names[0]]
            options.employee_names.pop(0) # don't need that value anymore
            for employee in options.employee_names:
                other_targets.append(data['e'][employee])

            if options.guest_names:
                for guest in options.guest_names:
                    other_targets.append(data['g'][guest])
        else:
            # theres no employees, use the first guest as target
            target = data['g'][options.guest_names[0]]
            options.guest_names.pop(0) # don't need that value anymore
            for guest in options.guest_names:
                other_targets.append(data['g'][guest])

        # [l1, u1, l2, u2...] increasing
        # [l1, u1, l2, u2...]

        # a = [(l1, u1)]
        # b = [(l1, u1), (l2, u2)...]
        # for i in range(len(a)):
        #     for j in range(len(b)):
        #         if a[i][1] > b[j][0]:
        #             return False

        return

    if options.all_bound:
        assert(len(options.lower_bounds) == 1)
        assert(len(options.upper_bounds) == 1)
        lower_bound = int(options.lower_bounds[0])
        upper_bound = int(options.upper_bounds[0])

        assert(lower_bound <= upper_bound)

        employees = []

        for employee in data['e']:
            info = data['e'][employee]
            if len(info['ga']) % 2 == 1:
                # still in the gallery, append the current time as final upper bound
                info['ga'].append(data['t'])
            if inbounds(info['ga'], lower_bound, upper_bound):
                employees.append(employee)

        employees.sort()

        if options.html:
            html = "<html><body><table>"
            for employee in employees:
                html += "<tr><th>" + employee + "</th></tr>"
            html += "</table></body></html>"
            sys.stdout.write(html)
        else:
            sys.stdout.write(",".join(employees))

        # success for all bound
        return


    if options.exclusive_bound:
        assert(len(options.lower_bounds) == 2)
        assert(len(options.upper_bounds) == 2)

        lower_bound = int(options.lower_bounds[0])
        upper_bound = int(options.upper_bounds[0])

        assert(lower_bound <= upper_bound)

        lower_exclude_bound = int(options.lower_bounds[1])
        upper_exclude_bound = int(options.upper_bounds[1])

        assert(lower_exclude_bound <= upper_exclude_bound)

        employees = []

        for employee in data['e']:
            info = data['e'][employee]
            if len(info['ga']) % 2 == 1:
                # still in the gallery, append the current time as final upper bound
                info['ga'].append(data['t'])
            if inbounds(info['ga'], lower_bound, upper_bound):
                if not inbounds(info['ga'], lower_exclude_bound, upper_exclude_bound):
                    employees.append(employee)

        employees.sort()

        if options.html:
            html = "<html><body><table>"
            for employee in employees:
                html += "<tr><th>" + employee + "</th></tr>"
            html += "</table></body></html>"
            sys.stdout.write(html)
        else:
            sys.stdout.write(",".join(employees))

        # success for exclusive bound
        return


def inbounds(arr, lower_bound, upper_bound):
    for idx, val in enumerate(arr):
        if val >= lower_bound:
            if idx % 2 == 0:
                # target just entered the gallery at the first point in the range
                # if target entered before the upper bound then success
                return val <= upper_bound
            else:
                # target just left the gallery after the lower bound which means he was in the gallery
                # at the point of the lower bound.  Success
                return True

    # target cannot be in gallery, he has no time signatures within the bounds
    return False


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument("-K", dest="token")
    parser.add_argument("-H", dest="html", action='store_true')
    parser.add_argument("-S", dest="current_state", action='store_true')
    parser.add_argument("-R", dest="rooms_entered", action='store_true')
    parser.add_argument("-T", dest="total_time", action='store_true')
    parser.add_argument("-I", dest="matching_rooms", action='store_true')
    parser.add_argument("-A", dest="all_bound", action='store_true')
    parser.add_argument("-B", dest="exclusive_bound", action='store_true')
    parser.add_argument("-E", dest="employee_names", action='append')
    parser.add_argument("-G", dest="guest_names", action='append')
    parser.add_argument("-L", dest="lower_bounds", action='append')
    parser.add_argument("-U", dest="upper_bounds", action='append')
    parser.add_argument('log', help='string for log path')



    args = parser.parse_args()
    invocation = [args.current_state, args.rooms_entered, args.total_time, args.matching_rooms, args.all_bound, args.exclusive_bound]
    if sum(invocation) != 1:
        # can't specify more than one option
        sys.stdout.write('invalid')
        sys.exit(-1)


    result = handle_read(args)

    # try:
    #     result = handle_read(args)
    # except Exception, e:
    #     # if log read wasn't successful it couldn't have been
    #     # generated by log append, thus integrity violation
    #     result = -2

    if result == -2:
        sys.stderr.write("integrity violation")
        sys.exit(-1)
    if result == -1:
        sys.stdout.write('invalid')
        sys.exit(-1)

if __name__ == "__main__":
    main()
    sys.exit(0)