Break It
=====

The organizers will make the source code of every build-it
team's submission available to the break-it teams. Included
with that code will be some standard
logfiles and information about how they were generated.  Break-it
teams will submit test cases that are evidence of a bug in a
particular submission. Test cases demonstrate bugs in one of three
categories: *correctness*, *integrity*, 
*confidentiality*. The test case format differs
depending on the category. All submissions of test cases are done via git.

Next we discuss the submission mechanism and format, the
per-submission logfiles that we will provide, and finally discuss the
different kinds of test cases.

Submission 
-----

Break submissions are made via [git](http://git-scm.com/). Create a
`break` folder in the top-level folder of your team's repository
(which is the same repository used to submit code during the build-it
phase if you participated in that phase). Within that folder, you will specify
test cases as XML files --- one file per test case.

Submission file format
-----

XML files that specify test cases will look like the following
(the format is explained below):

    <test team="9" type="correctness">
      <inputfile name="out_input">LVQgMCAtSyBCRlVYVU1YVSAtRyBPREEgLUEgQUlDVUNMTUQKLVQgMSAtSyBCRlVYVU1YVSAtRyBPREEgLUwgQUlDVUNMTUQK</inputfile>
      <commands>
        <command> 
          <program>logappend</program>
          <args>-K secret -T 0 -G GERDA -A log</args>
        </command>
        <command> 
          <program>logappend</program>
          <args>-K secret -T 1 -G GERDA -A -R 16 log</args>
        </command>
        <command> 
          <program>logappend</program>
          <args>-K secret -T 2 -G ROSALINE -A log</args>
        </command>
        <command> 
          <program>logread</program>
          <args>-K secret -R -G GERDA log</args>
          <output>16</output> 
          <erroutput/>
          <returncode>0</returncode>
        </command>
      </commands>
    </test>

The type of the test is specified in the *type* attribute with
either *correctness*, *integrity*, or *confidentiality*.  The team
whose submission this test proves is buggy is identified in the *team*
attribute, and is specified with an integer team ID from the team's
source code. The *logfile* attribute specifies the input log to use;
it will name a file provided by the organizers, as described in 
detail shortly. If you want to start with a blank log, you can omit the 
*logfile* attribute.

Each *command* under *commands* will, under the *args* parameter,
specify command lines to `logappend` or `logread`, as specified by the
*program* tag, as applied to the
already-specified *logfile*. The *output* parameter of a command specifies its expected output
to stdout (if any). Output to stderr (if any) is specified by
the *erroutput* attribute. Such output is newline (and whitespace)
sensitive. Specifying the return code is done with the *returncode*
attribute. If *output* or *stderr* are not specified, output and stderr are assumed to be blank. If *returncode* is not specified, it is assumed to be 0.

The *inputfile* parameter is used to provide substitute logfile
contents, i.e., instead of the contents originally in the specified
`logfile`. These contents are [base64-encoded](http://www.base64encode.org/). This parameter is used
in integrity tests (only), discussed below.

Correctness violations should also be accompanied by a bug report,
described below.

Supplied Log Files
------------------
Prior to each break-it team receiving access to it, a build-it team's
submission will be modified to contain a top-level
directory called `supplied_logfiles`. This directory will contain
several logfiles that were generated by that team's
implementation. Some will be accompanied with complete transcripts of
the `logappend` commands that generated the file, as well as the
authentication token, whereas some will have the transcripts, but
without an accompanying token (which is redacted from the
transcript). Some will contain neither token nor transcript.

These logs will be named by an alphanumeric string, for example:

 * `a941f06a58b361fdc279e75b29ad34227f53f8b8` is the log produced by a submission
 * `a941f06a58b361fdc279e75b29ad34227f53f8b8.logappend` is the transcript of the command line invocations of `logappend` used to create the log. This file might not be present for some logs, and in some transcripts the token used might be redacted.
 * `a941f06a58b361fdc279e75b29ad34227f53f8b8.token` is a file that contains the authentication token used to produce this log. This file will not be present for some logs; for those logs that contain a transcript but no token, the token will be redacted from the transcript.

When submitting tests that are based on supplied logs, you will
specify the name of the log in the *logfile* parameter.

There are three types of break-it tests you can submit, described
next.

Correctness Violations
----------------------
A correctness violation represents a deviation from the
specification. This could take the form of a crash, invalid output, or
incorrect responses to queries. To demonstrate a correctness
violation, submit a test with the *type* attribute set to
`correctness` and *commands* attributes to
demonstrate the correctness error. The elements of *commands* can
describe steps to build a log or append to a specified log (i.e., from
those we supply, with that log specified via the *logfile*
attribute). Also include an *output* and/or *erroutput* element in the
*command* element to *specify what a non-buggy implementation
should display*. In other words, this test should pass on a correct
implementation, but will fail on the specified submission. Any
*inputfile* parameter will be ignored. 

As an example, if you wanted to submit a testcase that is evidence of
a correctness violation in team 10's submission, you could create a
file `orangelemon1.xml` like so:

    <test team="10" type="correctness">
      <commands>
        <command> 
          <program>logappend</program> 
          <args>-K secret -T 0 -G GERDA -A log</args>
        </command>
        <command> 
          <program>logappend</program> 
          <args>-K secret -T 1 -G GERDA -A -R 16 log</args>
        </command>
        <command>
          <program>logread</program>
          <args>-K secret -R -G GERDA log</args>
          <output>16</output>
        </command>
      </commands>
    </test>

For correctness violations, *provide a textual justification for why you think
the test case you are submitting is indeed a bug*. Do this in a file
ending with `.txt` with the same name as your `.xml` file. This file
should be no more than 250 words. It may refer to relevant portions of
this spec (by HTML file name and line/section number) and/or line numbers
in the submitted code, if you like.

Integrity Violations
--------------------
An integrity violation occurs when an attacker can successfully modify
a log without knowledge of the token used to produce that
file. Evidence of successful modification is that the modified file is
interpreted correctly by `logread` (when using the token that was
used to create the original log). 

To demonstrate that this is possible, the
*inputfile* attribute should be a modified version of one of the
supplied logs for which no key was provided, but for which there
is a transcript. The *command* attribute should contain a
query, with the name of the original log specified, but no token
provided. A correct implementation should always exit with the error
"integrity violation"; an *incorrect* one will produce some other
output. Any *commands*, *returncode*, *erroutput* or *output* attribute
will be ignored. 

Here is an example demonstrating an integrity violation against team 9.

    <test team="9" type="integrity" logfile="integ9">
      <inputfile name="replacement">LVQgMCAtSyBCRlVYVU1YVSAtRyBPREEgLUEgQUlDVUNMTUQKLVQgMSAtSyBCRlVYVU1YVSAtRyBPREEgLUwgQUlDVUNMTUQK</inputfile>
      <commands>
        <command> 
          <program>logread</program>
          <args>-R -G GERDA</args> 
        </command>
      </commands>
    </test>

This tells the testing framework to run team 9's `logread` against
both our "integ9" file and the contestant-provided "replacement" file,
whose contents are defined by *inputfile*; in both cases `logread` is
run using the correct authentication token. If the query
command against "integ9" logfile and against the "replacement" file
produce different non-zero lenth standard outs and no errors, then an integrity violation
has been detected.

Confidentiality Violations
--------------------------
A confidentiality violation occurs when an attacker can infer
information about the contents of a log without knowledge of the
token or transcript. Evidence of such a violation is a successful
guess of an outcome of a query on the file, despite not knowing the
token or the transcript. 

To demonstrate that this is possible,
the *commands* attribute should contain a query
provided with the name of one of the supplied logfiles (specified via the *logfile* attribute) that was
not accompanied by a token or transcript, along with a
*output* attribute that contains the expected answer, had
the token been given. Our testing infrastructure will run with the
token, and thus if the expected output is indeed produced, it is clear
that the break-it team has reverse-engineered the contents of the
file. Any *commands* or *inputfile* attributes will
be ignored.

Here is an example of submitting a confidentiality test against team
9. In this test, the submitting team knows the room information for
GERDA, even though the logfile "conf8" was provided with neither token
nor transcript.

    <test team="9" type="confidentiality" logfile="conf8">
      <commands>
        <command> 
          <program>logread</program> />
          <args>-R -G GERDA</args> 
          <output>16</output>
        </command>
      </commands>
    </test>

Scoring
-----

Both integrity and confidentiality violations are considered vulnerabilities
by the scoring system. Any correctness violation that results in a crash or the printing of 
"I pwn you" to stderr counts as a vulnerability as well. All other correctness violations are not
scored as vulnerabiltiies. If you have
reason to argue that other correctness violations should be considered
security relevant, include the justification in your error report.
