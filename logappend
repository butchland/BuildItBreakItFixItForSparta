#!/usr/bin/env python

import argparse
import sys
import os.path
import hashlib
from Crypto.Cipher import AES
from Crypto import Random

HARDCODED_STRING = "e6f5bfbaae81a4496b5489f"

def handle_options(options, log_data=None):
    line = ""
    minimum_timestamp = 0
    if options.timestamp:
        if options.timestamp <= 0:
            # timestamps must be positive
            return -1
        #print options.timestamp
        line = line + str(options.timestamp) + ","
    else:
        return -1
        
    if options.employee_name and options.guest_name: # can't both exist
        return -1
    if options.employee_name == options.guest_name: # can't both not exist
        return -1
    if options.employee_name:
        if options.employee_name.isalpha():
            line += "E,"+options.employee_name+","
        else:
            return -1
    if options.guest_name:
        if options.guest_name.isalpha():
            line += "G,"+options.guest_name+","
        else:
            return -1
        
    if options.arrival == options.departure: # mutually exclusive
        return -1
    if options.arrival:
        line += "A,"
    if options.departure:
        line += "D,"
    if options.room_id:
        if options.room_id <= 0:
            return -1
        line += str(options.room_id)
    else:
        line += "-1" # main gallery

    return line

def encrypt_to_file(file_path, data, options, writeString=False):
    f=open(file_path, 'w')
    nonce = Random.new().read(AES.block_size)
    if writeString:
        message = HARDCODED_STRING + "\n" + str(data)
    else:
        message = str(data)
    # encrypted under the -K option passed in as a 256 hash
    key = hashlib.sha256(options.token).digest()

    obj = AES.new(key, AES.MODE_CFB, nonce)
    ciphertext = obj.encrypt(message)

    print(message)

    # first line of file is unencrypted nonce, 2nd line is encrypted
    # first line of encrypted is the hardcoded string, rest is log data
    f.write(nonce + "\n" + ciphertext)
    f.close()


def handle_single_command(options):
    log_path = options.log

    if log_path == None:
        # we need the last argument to be the path to log
        return -1

    if options.token == None:
        # need to submit a token
        return -1

    if os.path.isfile(log_path):
        # appending to an existing log
        f=open(log_path, 'r')
        lines = f.readlines()
        f.close()
        nonce = lines[0].rstrip() # remove new line
        ciphertext = ""
        for line in lines[1:]:
            ciphertext += line.rstrip()
        #ciphertext = "".join(lines[1:])

        # decrypted under the -K option passed in as a 256 hash
        key = hashlib.sha256(options.token).digest()
        obj = AES.new(key, AES.MODE_CFB, nonce)

        message = obj.decrypt(ciphertext)
        data = message.splitlines()
        if data[0] != HARDCODED_STRING:
            # token was not correct if it didn't decrypt
            # to the hardcoded string properly
            return -2

        result = handle_options(options, data[1:])
        if result == -1:
            return -1
        # data is new line separated
        # each line has comma separated
        to_encrypt = "\n".join(data[1:] + [result])
        encrypt_to_file(log_path, to_encrypt, options, writeString=True)
    else:
        # this is a new log

        data = handle_options(options)

        encrypt_to_file(log_path, data, options, writeString=True)
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-T", type=int, dest="timestamp")
    parser.add_argument("-K", dest="token")
    parser.add_argument("-E", dest="employee_name")
    parser.add_argument("-G", dest="guest_name")
    parser.add_argument("-A", dest="arrival", action='store_true')
    parser.add_argument("-L", dest="departure", action='store_true')
    parser.add_argument("-R", type=int, dest="room_id")
    parser.add_argument("-B", dest="file")
    parser.add_argument("log", help='string for log path')

    options = parser.parse_args()

    # TODO handle the -B option

    result = handle_single_command(options)
    if result == -2:
        sys.stderr.write("security error")
        sys.exit(-1)
    if result == -1:
        sys.stdout.write('invalid')
        sys.exit(-1)


if __name__ == "__main__":
    main()

